name: CI

on:
  push:
    branches: [ master, dev, main ]
  pull_request:
    branches: [ master, dev, main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for migrations (staging or production)'
        required: false
        default: 'staging'

jobs:
  backend:
    name: "Backend: Build & Tests"
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: root
          POSTGRES_PASSWORD: rootpwd
          POSTGRES_DB: kollector_test
        options: >-
          --health-cmd="pg_isready -U root -d kollector_test"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'
  frontend:
    name: "Frontend: Lint, Test, Build"
    runs-on: ubuntu-latest
    needs: backend
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install
        working-directory: frontend
        run: npm ci

      - name: Lint
        working-directory: frontend
        run: npm run lint

      - name: Unit tests
        working-directory: frontend
        env:
          NEXT_PUBLIC_API_BASE_URL: http://localhost:5072
          NEXT_PUBLIC_GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE__CLIENTID }}
        run: npm run test -- --ci

      - name: Build
        working-directory: frontend
        env:
          NEXT_PUBLIC_API_BASE_URL: http://localhost:5072
          NEXT_PUBLIC_GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE__CLIENTID }}
        run: npm run build

  worker_deploy:
    name: "Cloudflare: Deploy Worker"
    runs-on: ubuntu-latest
    needs: frontend
    if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/dev'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy worker
        working-directory: worker
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          if [ "${{ github.ref }}" = "refs/heads/dev" ]; then
            npx wrangler deploy --config wrangler.staging.toml
          else
            npx wrangler deploy --config wrangler.prod.toml
          fi

  render_deploy:
    name: "Render: Trigger Staging Deploy"
    runs-on: ubuntu-latest
    needs: frontend
    if: github.ref == 'refs/heads/dev'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Trigger Render deploy (staging)
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_SERVICE_ID_STAGING: ${{ secrets.RENDER_SERVICE_ID_STAGING }}
        run: |
          if [ -z "$RENDER_API_KEY" ] || [ -z "$RENDER_SERVICE_ID_STAGING" ]; then
            echo "Render deploy secrets are not set. Skipping deploy.";
            exit 1;
          fi
          echo "Triggering Render deploy for service $RENDER_SERVICE_ID_STAGING"
          curl -s -X POST "https://api.render.com/v1/services/${RENDER_SERVICE_ID_STAGING}/deploys" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Content-Type: application/json" \
            -d '{}' \
            | jq -r '.service | .id, .status' || true


  pages_deploy:
    name: "Cloudflare Pages: Deploy Frontend"
    runs-on: ubuntu-latest
    needs: frontend
    if: github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/master'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      # @cloudflare/next-on-pages adapts the Next.js build for Cloudflare's edge runtime.
      # It runs `next build` internally (webpack, not Turbopack) then transforms the output.
      # NEXT_PUBLIC_* vars are baked in at build time so we rebuild per environment.
      - name: Build for Cloudflare Pages (staging — dev branch)
        if: github.ref == 'refs/heads/dev'
        working-directory: frontend
        env:
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL_STAGING }}
          NEXT_PUBLIC_GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE__CLIENTID }}
          NEXT_PUBLIC_API_TIMEOUT_MS: "20000"
        run: npx @cloudflare/next-on-pages@1

      - name: Build for Cloudflare Pages (production — master branch)
        if: github.ref == 'refs/heads/master'
        working-directory: frontend
        env:
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL_PROD }}
          NEXT_PUBLIC_GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE__CLIENTID }}
          NEXT_PUBLIC_API_TIMEOUT_MS: "20000"
        run: npx @cloudflare/next-on-pages@1

      # Deploys .vercel/output/static to Cloudflare Pages.
      # dev branch    → preview deployment (e.g. dev.kollector-scum-frontend.pages.dev)
      # master branch → production deployment (kollector-scum-frontend.pages.dev)
      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: 1c96409b15483aeb26499da3e9a1cb2b
          projectName: kollector-scum-frontend
          directory: frontend/.vercel/output/static
          gitHubToken: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.ref_name }}

  staging-health:
    name: "Staging: Health check"
    runs-on: ubuntu-latest
    needs: frontend
    steps:
      - name: Check staging health endpoint
        run: |
          STAGING_URL="https://kollector-scum-staging-api.onrender.com/health"
          echo "Pinging $STAGING_URL"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 --retry 3 "$STAGING_URL")
          if [ "$STATUS" != "200" ]; then
            echo "Staging health check failed with HTTP status: $STATUS"
            exit 1
          fi
          echo "Staging is healthy (200)"

  migrate:
    name: "Run EF Core Migrations (manual)"
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Make migration script executable
        run: chmod +x backend/scripts/apply-ef-migrations.sh

      - name: Create .env from secrets
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "Creating .env from secrets (staging/prod DB URLs)"
          echo "KOLLECTOR_STAGING_DB_URL=\"${{ secrets.KOLLECTOR_STAGING_DB_URL }}\"" > .env
          echo "KOLLECTOR_PROD_DB_URL=\"${{ secrets.KOLLECTOR_PROD_DB_URL }}\"" >> .env

      - name: Run migrations
        env:
          KOLLECTOR_STAGING_DB_URL: ${{ secrets.KOLLECTOR_STAGING_DB_URL }}
          KOLLECTOR_PROD_DB_URL: ${{ secrets.KOLLECTOR_PROD_DB_URL }}
        run: |
          echo "Running migrations for '${{ github.event.inputs.environment }}'"
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            ./backend/scripts/apply-ef-migrations.sh --production
          else
            ./backend/scripts/apply-ef-migrations.sh --staging
          fi